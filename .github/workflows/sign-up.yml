name: Process Sign-up Discussion Messages

on:
  discussion:
    types: [ created ]
  workflow_dispatch:

concurrency:
  group: "signup-processing"
  cancel-in-progress: false

env:
  GH_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
  REPO: AdHoc-Protocol
  ORG: AdHoc-Protocol
  CATEGORY_SLUG: "sign-up"

jobs:
  # Job 1: Get prerequisite IDs that other jobs will need.
  setup:
    runs-on: ubuntu-latest
    outputs:
      category_id: ${{ steps.get_ids.outputs.category_id }}
      org_id: ${{ steps.get_ids.outputs.org_id }}
    steps:
      - name: Get Discussion Category and Organization IDs
        id: get_ids
        run: |
          IDS_JSON=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $categorySlug: String!) {
              repository(owner: $owner, name: $name) {
                discussionCategory(slug: $categorySlug) {
                  id
                }
              }
              organization(login: $owner) {
                id
              }
            }
          ' -F owner="$ORG" -F name="$REPO" -F categorySlug="$CATEGORY_SLUG")
          
          CATEGORY_ID=$(echo "$IDS_JSON" | jq -r '.data.repository.discussionCategory.id')
          ORG_ID=$(echo "$IDS_JSON" | jq -r '.data.organization.id')
          
          if [[ -z "$CATEGORY_ID" || "$CATEGORY_ID" == "null" ]]; then
            echo "::error::Category ID not found for slug '${CATEGORY_SLUG}'"
            exit 1
          fi
          
          echo "category_id=$CATEGORY_ID" >> $GITHUB_OUTPUT
          echo "org_id=$ORG_ID" >> $GITHUB_OUTPUT
          echo "✓ Fetched Category ID: $CATEGORY_ID"
          echo "✓ Fetched Organization ID: $ORG_ID"

  # Job 2: Find all unique users who need to be processed.
  discover:
    runs-on: ubuntu-latest
    needs: setup
    outputs:
      users_json: ${{ steps.get_users.outputs.users_json }}
      user_count: ${{ steps.get_users.outputs.user_count }}
    steps:
      - name: Fetch Unique Sign-up Users
        id: get_users
        env:
          CATEGORY_ID: ${{ needs.setup.outputs.category_id }}
        run: |
          # This single, efficient query gets all unique users and all required data fields.
          USERS_PAYLOAD=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $categoryId: ID!) {
              repository(owner: $owner, name: $name) {
                discussions(first: 100, categoryId: $categoryId) {
                  nodes {
                    author {
                      login
                      url
                      avatarUrl
                      ... on User {
                        id
                        createdAt
                      }
                    }
                  }
                }
              }
            }
          ' -F owner="$ORG" -F name="$REPO" -F categoryId="$CATEGORY_ID" | \
          jq -c '[.data.repository.discussions.nodes | .[] | .author] | unique_by(.login)')

          USER_COUNT=$(echo "$USERS_PAYLOAD" | jq 'length')

          if [[ "$USER_COUNT" -eq 0 ]]; then
            echo "No new sign-up discussions to process."
          else
            echo "Found $USER_COUNT unique user(s) to process."
          fi
          
          echo "users_json=$USERS_PAYLOAD" >> $GITHUB_OUTPUT
          echo "user_count=$USER_COUNT" >> $GITHUB_OUTPUT

  # Job 3: Process each user in parallel.
  process:
    runs-on: ubuntu-latest
    needs: [setup, discover]
    if: needs.discover.outputs.user_count > 0
    strategy:
      fail-fast: false # Allows other users to continue processing even if one fails.
      matrix:
        user: ${{ fromJson(needs.discover.outputs.users_json) }}

    steps:
      - name: Send Registration & Provision Project for ${{ matrix.user.login }}
        env:
          SIGN_UP_URL: ${{ secrets.SIGN_UP_URL }}
          SIGN_UP_HEADER: ${{ secrets.SIGN_UP_HEADER }}
          ORG_ID: ${{ needs.setup.outputs.org_id }}
          USER_LOGIN: ${{ matrix.user.login }}
          USER_ID: ${{ matrix.user.id }}
          USER_URL: ${{ matrix.user.url }}
          USER_AVATAR_URL: ${{ matrix.user.avatarUrl }}
          USER_CREATED_AT: ${{ matrix.user.createdAt }}
        run: |
          echo "--- Processing user: $USER_LOGIN ---"
          
          # 1. Prepare data
          uuid=$(uuidgen)
          created_at_ms=$(date -d "$USER_CREATED_AT" +%s%3N)
          
          # 2. Send user data via HTTP GET request
          echo "Sending registration request..."
          http_status=$(curl -s -L -G \
            --max-redirs 1 \
            -w "%{http_code}" \
            -o /dev/null \
            "$SIGN_UP_URL" \
            --data-urlencode "h=$SIGN_UP_HEADER" \
            --data-urlencode "u=$uuid" \
            --data-urlencode "t=$created_at_ms" \
            --data-urlencode "i=$USER_ID" \
            --data-urlencode "l=$USER_LOGIN" 2>&1 | tee /tmp/curl_debug.log | grep -E "^> GET|^< Location|^< HTTP")
          
          # Then, after curl, add:
          echo "Full verbose debug saved to /tmp/curl_debug.log (check for GET and Location lines)"

          if [[ "$http_status" -lt 200 || "$http_status" -ge 300 ]]; then
            echo "::error::Received non-successful HTTP status '$http_status' for user '$USER_LOGIN'. Aborting this user's processing."
            exit 1
          fi
          echo "✓ Successfully registered (HTTP $http_status). Now provisioning project."

          # 3. Check for and provision a GitHub Project for the user
          PROJECT_ID=$(gh api graphql -f query='
            query($org: String!, $login: String!) {
              organization(login: $org) {
                projectsV2(first: 1, query: $login) { nodes { id } }
              }
            }' -F org="$ORG" -F login="$USER_LOGIN" --jq '.data.organization.projectsV2.nodes | .[0]?.id')

          if [[ -z "$PROJECT_ID" || "$PROJECT_ID" == "null" ]]; then
            echo "Creating new project for $USER_LOGIN..."
            PROJECT_ID=$(gh api graphql -f query='
              mutation($ownerId: ID!, $title: String!) {
                createProjectV2(input: {ownerId: $ownerId, title: $title}) {
                  projectV2 { id }
                }
              }' -F ownerId="$ORG_ID" -F title="$USER_LOGIN" --jq '.data.createProjectV2.projectV2.id')
          
            README_CONTENT="# [$USER_LOGIN]($USER_URL)  \n\n![Avatar]($USER_AVATAR_URL)"
          
            gh api graphql -f query='
              mutation($projectId: ID!, $readme: String!) {
                updateProjectV2(input: {projectId: $projectId, readme: $readme, public: false}) {
                  projectV2 { id }
                }
              }' -F projectId="$PROJECT_ID" -F readme="$README_CONTENT"
          
            gh api graphql -f query='
              mutation($projectId: ID!, $userId: ID!) {
                updateProjectV2Collaborators(input: {
                  projectId: $projectId, 
                  collaborators: [{userId: $userId, role: WRITER}]
                }) { clientMutationId }
              }' -F projectId="$PROJECT_ID" -F userId="$USER_ID"
            echo "✓ Invited $USER_LOGIN to new project with write access."
          else
            echo "Project already exists. Using existing project ID: $PROJECT_ID"
          fi
          
          # 4. Add the sign-up UUID as a draft issue to their project
          gh api graphql -f query='
            mutation($projectId: ID!, $title: String!) {
              addProjectV2DraftIssue(input: {projectId: $projectId, title: $title}) {
                clientMutationId
              }
            }' -F projectId="$PROJECT_ID" -F title="$uuid"
          echo "✓ Added sign-up record ($uuid) to project."

  # Job 4: Clean up all discussions after processing is complete.
  cleanup:
    runs-on: ubuntu-latest
    needs: [setup, discover, process]
    # This job runs only if discovery and processing succeeded.
    if: always() && needs.discover.result == 'success' && needs.process.result == 'success'
    steps:
      - name: Delete All Processed Sign-up Discussions
        env:
          CATEGORY_ID: ${{ needs.setup.outputs.category_id }}
        run: |
          echo "Cleaning up all discussions in the 'Sign up' category..."
          DISCUSSION_IDS=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $categoryId: ID!) {
              repository(owner: $owner, name: $name) {
                discussions(first: 100, categoryId: $categoryId) {
                  nodes { id }
                }
              }
            }' -F owner="$ORG" -F name="$REPO" -F categoryId="$CATEGORY_ID" | jq -r '.data.repository.discussions.nodes[].id')
          
          if [[ -z "$DISCUSSION_IDS" ]]; then
            echo "No discussions to delete."
            exit 0
          fi
          
          for id in $DISCUSSION_IDS; do
            echo "Deleting discussion with ID: $id"
            gh api graphql -f query='
              mutation($id: ID!) {
                deleteDiscussion(input: {id: $id}) { clientMutationId }
              }' -F id="$id" || echo "::warning::Failed to delete discussion with ID: $id"
            sleep 1 # Crucial to avoid hitting secondary rate limits.
          done
          echo "✓ Cleanup complete."
