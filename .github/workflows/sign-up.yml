name: Process Sign-up Discussion Messages

on:
  discussion:
    types: [created]
  workflow_dispatch:

concurrency:
  group: "only one instance"
  cancel-in-progress: true
  
env:
  GH_TOKEN: ${{ secrets.GH_PROJECT_TOKEN }}
  REPO: AdHoc-Protocol
  ORG: AdHoc-Protocol
  CATEGORY_NAME: "Sign up"

jobs:
  process-messages:
    runs-on: ubuntu-latest
    steps:
      - name: Get Discussion Category ID for "Sign up"
        id: fetch_category_id
        run: |
          CATEGORY_ID=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $categoryName: String!) {
              repository(owner: $owner, name: $name) {
                discussionCategory(name: $categoryName) {
                  id
                }
              }
            }
          ' -F owner="$ORG" -F name="$REPO" -F categoryName="$CATEGORY_NAME" | jq -r '.data.repository.discussionCategory.id')

          if [[ -z "$CATEGORY_ID" ]]; then
            echo "Error: Category ID not found for '$CATEGORY_NAME'" >&2
            exit 1
          fi
          echo "Fetched Category ID: $CATEGORY_ID"

      - name: Collect discussion messages in "Sign up" category
        id: process_messages
        run: |
          MESSAGES=$(gh api graphql -f query='
            query($owner: String!, $name: String!, $categoryId: ID!) {
              repository(owner: $owner, name: $name) {
                discussions(first: 100, categoryId: $categoryId) {
                  nodes {
                    author {
                      login
                      url
                      avatarUrl
                    }
                    createdAt
                    id
                  }
                }
              }
            }
          ' -F owner="$ORG" -F name="$REPO" -F categoryId="${{ steps.fetch_category_id.outputs.category_id }}")

          if [[ -z "$MESSAGES" ]]; then
            echo "No messages found in 'Sign up' category. Exiting..."
            exit 0
          fi

          echo "$MESSAGES" > messages.json
          echo "Collected messages in 'Sign up' category."

      - name: Collect Unique Messages
        run: |
          # Parse the messages.json file and remove duplicates
          jq -r '.data.repository.discussions.nodes 
          | unique_by(.author.login) 
          | .[] 
          | "\(.author.login), \(.author.url), \(.author.avatarUrl), \(.id)"' messages.json > unique_messages.txt
          
          echo "Collected and processed unique messages in '$CATEGORY_NAME' category."
           
      - name: Send messages via websocat
        env:
          SIGN_UP_URL: ${{ secrets.SIGN_UP_URL }}
          SIGN_UP_HEADER: ${{ secrets.SIGN_UP_HEADER }}
        run: |
          # Download and set up websocat
          wget -q https://github.com/vi/websocat/releases/download/v1.8.0/websocat_amd64-linux -O /usr/local/bin/websocat
          chmod +x /usr/local/bin/websocat
      
          # Function to convert hex to binary
          hex_to_binary() {
              echo -n "$1" | xxd -r -p
          }
      
          # Function to convert integer to little-endian bytes
          int_to_le_bytes() {
              local num=$1
              printf '\x%02x\x%02x\x%02x\x%02x' \
                  $((num & 0xFF)) \
                  $(((num >> 8) & 0xFF)) \
                  $(((num >> 16) & 0xFF)) \
                  $(((num >> 24) & 0xFF))
          }
      
          # Convert header from hex to binary
          binary_header=$(hex_to_binary "$SIGN_UP_HEADER")
      
          # Get file size and convert to little-endian bytes
          file_size=$(stat -c%s unique_messages.txt)
          le_file_size=$(int_to_le_bytes $file_size)
      
          # Send binary header, file size, and message content via websocat
          {
              printf "%s" "$binary_header"
              printf "%s" "$le_file_size"
              cat unique_messages.txt
          } | websocat --binary $SIGN_UP_URL | {
              # Wait for a reply "OK" within 5 seconds
              timeout 5 grep -q "OK"
          }
         
      - name: Get Organization ID
        id: get_org_id
        if: ${{ success() }}
        run: |
          ORG_ID=$(gh api graphql -f query='
            query($organization: String!) {
              organization(login: $organization) {
                id
              }
            }
          ' -F organization="$ORG" | jq -r '.data.organization.id')
          echo "org_id=$ORG_ID" >> $GITHUB_OUTPUT

      - name: Process Unique Messages
        if: ${{ success() }}
        run: |
          while IFS=',' read -r login url avatarUrl id; do
            # Check if a project with title "$login" exists in the organization
            USER_PROJECTS=$(gh api graphql -f query='
              query($organization: String!, $login: String!) {
                organization(login: $organization) {
                  projectsV2(first: 1, query: $login) {
                    totalCount
                  }
                }
              }
            ' -F organization="$ORG" -F login="$login" | jq -r '.data.organization.projectsV2.totalCount')

            if [[ "$USER_PROJECTS" == "0" ]]; then
              echo "Creating new project for $login..."
              NEW_PROJECT_ID=$(gh api graphql -f query='
                mutation($ownerId: ID!, $title: String!) {
                  createProjectV2(input: {ownerId: $ownerId, title: $title}) {
                    projectV2 {
                      id
                    }
                  }
                }
              ' -F ownerId="${{ steps.get_org_id.outputs.org_id }}" -F title="$login" | jq -r '.data.createProjectV2.projectV2.id')

              README_CONTENT=$(echo -e "# [$login]($url)\n\n![image]($avatarUrl)")
              
              gh api graphql -f query='
                mutation($projectId: ID!, $readme: String!) {
                  updateProjectV2(input: {projectId: $projectId, readme: $readme, public: false}) {
                    projectV2 {
                      id
                    }
                  }
                }
              ' -F projectId="$NEW_PROJECT_ID" -F readme="$README_CONTENT"

              gh api graphql -f query='
                mutation($projectId: ID!, $title: String!) {
                  addProjectV2DraftIssue(input: {projectId: $projectId, title: $title}) {
                    clientMutationId
                  }
                }' -F projectId="$NEW_PROJECT_ID" -F title="$id"

              # Get USER_ID from GitHub API
              USER_ID=$(gh api graphql -H "X-Github-Next-Global-ID: 1" -f query='
                query($login: String!) {
                  user(login: $login) {
                    id
                  }
                }
              ' -F login="$login" --jq '.data.user.id')
              
              # Update ProjectV2 Collaborators
              gh api graphql -f query='
                mutation($projectId: ID!, $userIds: ID!) {
                  updateProjectV2Collaborators(input: {
                    projectId: $projectId, 
                    collaborators: [{userId: $userIds, role: READER}]
                  }) {
                    clientMutationId
                  }
                }
              ' -F projectId="$NEW_PROJECT_ID" -F userIds="$USER_ID"

              echo "\nInvited $login to project $login with read-write access"
            else
              echo "\nProject for $login already exists, skipping..."
            fi
          done < unique_messages.txt

      - name: Delete processed messages
        if: ${{ success() }}
        run: |
          jq -r '.data.repository.discussions.nodes | .[] | .id' messages.json | while read id; do
            gh api graphql -f query='
              mutation($id: ID!) {
                deleteDiscussion(input: {id: $id}) {
                  clientMutationId
                }
              }
            ' -F id="$id"
          done
